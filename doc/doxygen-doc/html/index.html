<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Locality (hwloc): hwloc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>hwloc</h1><h3>0.9.2 </h3><h1 class="sub">Portable abstraction of hierarchical architectures for high-performance computing</h1>
<hr/>
 
<div class="section" id="introduction">
 <h2><a class="anchor" id="Introduction">
Introduction</a></h2>
<p>hwloc provides command line tools and a C API to obtain the hierarchical map of key computing elements, such as: NUMA memory nodes, shared caches, processor sockets, processor cores, and processor "threads". hwloc also gathers various attributes such as cache and memory information, and is portable across a variety of different operating systems and platforms.</p>
<p>hwloc primarily aims at helping high-performance computing (HPC) applications, but is also applicable to any project seeking to exploit code and/or data locality on modern computing platforms.</p>
<p>Note that the hwloc project represents the merger of the libtopology project from INRIA and the Portable Linux Processor Affinity (PLPA) sub-project from Open MPI. <em>Both of these prior projects are now deprecated.</em> The first hwloc release is essentially a "re-branding" of the libtopology code base, but with both a few genuinely new features and a few PLPA-like features added in. More new features and more PLPA-like features will be added to hwloc over time.</p>
<p>hwloc supports the following operating systems:</p>
<ul>
<li>
Linux (including old kernels not having sysfs topology information, with knowledge of cpusets, offline cpus, and Kerrighed support) </li>
<li>
Solaris </li>
<li>
AIX </li>
<li>
Darwin / OS X </li>
<li>
OSF/1 (a.k.a., Tru64) </li>
<li>
HP-UX </li>
<li>
Microsoft Windows </li>
</ul>
<p>hwloc only reports the number of processors on unsupported operating systems; no topology information is available.</p>
<p>For development and debugging purposes, hwloc also offers the ability to work on "fake" topologies:</p>
<ul>
<li>
Symmetrical tree of resources generated from a list of level arities </li>
<li>
Remote machine simulation through the gathering of Linux sysfs topology files </li>
</ul>
<p>hwloc can display the topology in a human-readable format, either in graphical mode (X11), or by exporting in one of several different formats, including: plain text, PDF, PNG, and FIG (see Examples below). Note that some of the export formats require additional support libraries.</p>
<p>hwloc offers a programming interface for manipulating topologies and objects. It also brings a powerful CPU bitmap API that is used to describe topology objects location on physical/logical processors. See the <a class="el" href="index.html#interface">Programming interface</a> below. It may also be used to binding applications onto certain cores or memory nodes. Several utility programs are also provided to ease command-line manipulation of topology objects, binding of processes, and so on.</p>
 
</div><div class="section" id="installation">
 <h2><a class="anchor" id="installation">
Installation</a></h2>
<p>hwloc (<a href="http://www.open-mpi.org/projects/hwloc/">http://www.open-mpi.org/projects/hwloc/</a>) is available under the BSD license. It is hosted as a sub-project of the overall Open MPI project (<a href="http://www.open-mpi.org/">http://www.open-mpi.org/</a>). Note that hwloc does not require any functionality from Open MPI -- it is a wholly separate (and much smaller!) project and code base. It just happens to be hosted as part of the overall Open MPI project.</p>
<p>Nightly development snapshots are available on the web site. Additionally, the code can be directly checked out of Subversion:</p>
<div class="fragment"><pre class="fragment">shell$ svn checkout http:<span class="comment">//svn.open-mpi.org/svn/hwloc/trunk hwloc-trunk</span>
shell$ cd hwloc-trunk
shell$ ./autogen.sh
</pre></div><p>Note that GNU Autoconf &gt;=2.60, Automake &gt;=1.10 and Libtool &gt;=2.2.6 are required when building from a Subversion checkout.</p>
<p>Installation by itself is the fairly common GNU-based process:</p>
<div class="fragment"><pre class="fragment">shell$ ./configure --prefix=...
shell$ make
shell$ make install
</pre></div><p>The hwloc command-line tool "lstopo" produces human-readable topology maps, as mentioned above. It can also export maps to the "fig" file format. Support for PDF, Postscript, and PNG exporting is provided if the "Cairo" development package can be found when hwloc is configured and build. Similarly, lstopo's XML support requires the libxml2 development package.</p>
 
</div><div class="section" id="examples">
 <h2><a class="anchor" id="examples">
Examples</a></h2>
<p>On a 4-socket 2-core machine with hyperthreading, the <code>lstopo</code> tool may show the following outputs:</p>
<div align="center">
<img src="dudley.png" alt="dudley.png"/>
</div>
 <div class="fragment"><pre class="fragment">System(15GB)
  Socket<span class="preprocessor">#0 + L3(4096KB)</span>
<span class="preprocessor"></span>    L2(1024KB) + L1(16KB) + Core#0
      P#0
      P#8
    L2(1024KB) + L1(16KB) + Core#1
      P#4
      P#12
  Socket#1 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core<span class="preprocessor">#0</span>
<span class="preprocessor"></span>      P#1
      P#9
    L2(1024KB) + L1(16KB) + Core#1
      P#5
      P#13
  Socket#2 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core<span class="preprocessor">#0</span>
<span class="preprocessor"></span>      P#2
      P#10
    L2(1024KB) + L1(16KB) + Core#1
      P#6
      P#14
  Socket#3 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core<span class="preprocessor">#0</span>
<span class="preprocessor"></span>      P#3
      P#11
    L2(1024KB) + L1(16KB) + Core#1
      P#7
      P#15
</pre></div><p>On a 4-socket 2-core Opteron NUMA machine, the <code>lstopo</code> tool may show the following outputs:</p>
<div align="center">
<img src="hagrid.png" alt="hagrid.png"/>
</div>
 <div class="fragment"><pre class="fragment">System(62GB)
  Node<span class="preprocessor">#0(8190MB) + Socket#0</span>
<span class="preprocessor"></span>    L2(1024KB) + L1(64KB) + Core#0 + P#0
    L2(1024KB) + L1(64KB) + Core#1 + P#1
  Node#1(8192MB) + Socket#1
    L2(1024KB) + L1(64KB) + Core#0 + P#2
    L2(1024KB) + L1(64KB) + Core#1 + P#3
  Node#2(8192MB) + Socket#2
    L2(1024KB) + L1(64KB) + Core#0 + P#4
    L2(1024KB) + L1(64KB) + Core#1 + P#5
  Node#3(8192MB) + Socket#3
    L2(1024KB) + L1(64KB) + Core#0 + P#6
    L2(1024KB) + L1(64KB) + Core#1 + P#7
  Node#4(8192MB) + Socket#4
    L2(1024KB) + L1(64KB) + Core#0 + P#8
    L2(1024KB) + L1(64KB) + Core#1 + P#9
  Node#5(8192MB) + Socket#5
    L2(1024KB) + L1(64KB) + Core#0 + P#10
    L2(1024KB) + L1(64KB) + Core#1 + P#11
  Node#6(8192MB) + Socket#6
    L2(1024KB) + L1(64KB) + Core#0 + P#12
    L2(1024KB) + L1(64KB) + Core#1 + P#13
  Node#7(8192MB) + Socket#7
    L2(1024KB) + L1(64KB) + Core#0 + P#14
    L2(1024KB) + L1(64KB) + Core#1 + P#15
</pre></div><p>On a 2-socket quad-core Xeon (pre-Nehalem, with 2 dual-core dies into each socket):</p>
<div align="center">
<img src="emmett.png" alt="emmett.png"/>
</div>
 <div class="fragment"><pre class="fragment">System(15GB)
  Socket<span class="preprocessor">#0</span>
<span class="preprocessor"></span>    L2(4096KB)
      L1(32KB) + Core<span class="preprocessor">#0 + P#0</span>
<span class="preprocessor"></span>      L1(32KB) + Core#1 + P#4
    L2(4096KB)
      L1(32KB) + Core<span class="preprocessor">#2 + P#2</span>
<span class="preprocessor"></span>      L1(32KB) + Core#3 + P#6
  Socket#1
    L2(4096KB)
      L1(32KB) + Core<span class="preprocessor">#0 + P#1</span>
<span class="preprocessor"></span>      L1(32KB) + Core#1 + P#5
    L2(4096KB)
      L1(32KB) + Core<span class="preprocessor">#2 + P#3</span>
<span class="preprocessor">      L1(32KB) + Core#3 + P#7</span>
</pre></div> 
</div><div class="section" id="interface">
<h2><a class="anchor" id="interface">
Programming interface</a></h2>
<p>The basic interface is available in <a class="el" href="hwloc_8h_source.html" title="The hwloc API.">hwloc.h</a>. It mostly offers low-level routines for advanced programmers that want to manually manipulate objects and follow links between them. Developers should look at <a class="el" href="helper_8h_source.html" title="High-level hwloc traversal helpers.">hwloc/helper.h</a>, which provides good higher-level topology traversal examples.</p>
<p>Each object contains a cpuset describing the list of processors that it contains. These cpusets may be used for <a class="el" href="group__hwlocality__binding.html">Binding</a>. hwloc offers an extensive cpuset manipulation interface in <a class="el" href="cpuset_8h_source.html" title="The Cpuset API, for use in hwloc itself.">hwloc/cpuset.h</a>.</p>
<p>Moreover, hwloc also comes with additional helpers for interoperability with several commonly used environments. For Linux, some specific helpers are available in <a class="el" href="linux_8h_source.html" title="Macros to help interaction between hwloc and Linux.">hwloc/linux.h</a>, and <a class="el" href="linux-libnuma_8h_source.html" title="Macros to help interaction between hwloc and Linux libnuma.">hwloc/linux-libnuma.h</a> if using libnuma. On glibc-based systems, additional helpers are available in <a class="el" href="glibc-sched_8h_source.html" title="Macros to help interaction between hwloc and glibc scheduling routines.">hwloc/glibc-sched.h</a>. For Linux systems with the OpenFabrics verbs library, some dedicated helpers are provided in <a class="el" href="openfabrics-verbs_8h_source.html" title="Macros to help interaction between hwloc and OpenFabrics verbs.">hwloc/openfabrics-verbs.h</a> (this helper file is not yet useful on non-Linux systems with the OpenFabrics verbs library).</p>
<p>To precisely define the vocabulary used by hwloc, a <a class="el" href="glossary.html">Glossary</a> is available and should probably be read first.</p>
<p>Further documentation is available in a full set of HTML pages, man pages, and self-contained PDF files (formatted for both both US letter and A4 formats) in the source tarball in doc/doxygen-doc/. If you are building from a Subversion checkout, you will need to have Doxygen and pdflatex installed -- the documentation will be built during the normal "make" process. The documentation is installed during "make
install" to $prefix/share/doc/hwloc/ and your systems default man page tree (under $prefix, of course).</p>
<p>The following section presents an example of API usage.</p>
<h2><a class="anchor" id="interface_example">
Interface example</a></h2>
<p>This section shows how to use hwloc with an small example <code>hwloc-hello.c</code> that just prints the topology and binds itself to the first processor of the second core of the machine.</p>
<p>Hardware Location provides a pkg-config object, so compiling the example boils down to</p>
<div class="fragment"><pre class="fragment">
CFLAGS += $(pkg-config --cflags hwloc)
LDLIBS += $(pkg-config --libs hwloc)
cc hwloc-hello.c $(CFLAGS) -o hwloc-hello $(LDLIBS)
</pre></div><div class="fragment"><pre class="fragment"><span class="comment">/* Example hwloc API program.</span>
<span class="comment"> *</span>
<span class="comment"> * Copyright © 2009 INRIA, Université Bordeaux 1</span>
<span class="comment"> *</span>
<span class="comment"> * topo-hello.c </span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;hwloc.h&gt;</span>

<span class="keyword">static</span> <span class="keywordtype">void</span> print_children(<a class="code" href="group__hwlocality__topology.html#ga9d1e76ee15a7dee158b786c30b6a6e38" title="Topology context.">hwloc_topology_t</a> topology, <a class="code" href="structhwloc__obj.html" title="Structure of a topology object.">hwloc_obj_t</a> obj, <span class="keywordtype">int</span> depth)
{
        <span class="keywordtype">char</span> <span class="keywordtype">string</span>[128];
        <span class="keywordtype">int</span> i;

        <a class="code" href="group__hwlocality__conversion.html#ga612dc210053b65d2466ac7ad39db92a4" title="Stringify a given topology object into a human-readable form.">hwloc_obj_snprintf</a>(<span class="keywordtype">string</span>, <span class="keyword">sizeof</span>(<span class="keywordtype">string</span>), topology, obj, <span class="stringliteral">&quot;#&quot;</span>, 0);
        printf(<span class="stringliteral">&quot;%*s%s\n&quot;</span>, 2*depth, <span class="stringliteral">&quot;&quot;</span>, <span class="keywordtype">string</span>);
        <span class="keywordflow">for</span> (i = 0; i &lt; obj-&gt;<a class="code" href="structhwloc__obj.html#aac3f6da35c9b57599909a44ce2b716c1" title="Number of children.">arity</a>; i++)
                print_children(topology, obj-&gt;<a class="code" href="structhwloc__obj.html#a04d05403da37bfe17cd63b7c7dd07b1f" title="Children, children[0 .. arity -1].">children</a>[i], depth + 1);
}

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
        <span class="comment">/* Topology object */</span>
        <a class="code" href="group__hwlocality__topology.html#ga9d1e76ee15a7dee158b786c30b6a6e38" title="Topology context.">hwloc_topology_t</a> topology;

        <span class="comment">/* Allocate and initialize topology object.  */</span>
        <a class="code" href="group__hwlocality__creation.html#ga03fd4a16d8b9ee1ffc32b25fd2f6bdfa" title="Allocate a topology context.">hwloc_topology_init</a>(&amp;topology);

        <span class="comment">/* ... Optionally, put detection configuration here to e.g. ignore some</span>
<span class="comment">           objects types, define a synthetic topology, etc....  The default is</span>
<span class="comment">           to detect all the objects of the machine that the caller is allowed</span>
<span class="comment">           to access.</span>
<span class="comment">           See Configure Topology Detection.  */</span>

        <span class="comment">/* Perform the topology detection.  */</span>
        <a class="code" href="group__hwlocality__creation.html#gabdf58d87ad77f6615fccdfe0535ff826" title="Build the actual topology.">hwloc_topology_load</a>(topology);


        <span class="comment">/* Optionally, get some additional topology information</span>
<span class="comment">         * in case we need the topology depth later.</span>
<span class="comment">         */</span>
        <span class="keywordtype">unsigned</span> topodepth = <a class="code" href="group__hwlocality__information.html#ga3cc2255e237b751a6c8efa8703b3daf5" title="Get the depth of the hierachical tree of objects.">hwloc_topology_get_depth</a>(topology);


        <span class="comment">/* Walk the topology with an array style, from level 0 (always the</span>
<span class="comment">         * system level) to the lowest level (always the proc level). */</span>
        <span class="keywordtype">int</span> depth, i;
        <span class="keywordtype">char</span> <span class="keywordtype">string</span>[128];
        <span class="keywordflow">for</span> (depth = 0; depth &lt; topodepth; depth++) {
                <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="group__hwlocality__information.html#gab17065e3d53455973844568d9f21c72c" title="Returns the width of level at depth depth.">hwloc_get_nbobjs_by_depth</a>(topology, depth); i++) {
                        <a class="code" href="group__hwlocality__conversion.html#ga612dc210053b65d2466ac7ad39db92a4" title="Stringify a given topology object into a human-readable form.">hwloc_obj_snprintf</a>(<span class="keywordtype">string</span>, <span class="keyword">sizeof</span>(<span class="keywordtype">string</span>), topology,
                                        <a class="code" href="group__hwlocality__traversal.html#gabf8a98ad085460a4982cc7b74c344b71" title="Returns the topology object at index index from depth depth.">hwloc_get_obj_by_depth</a>(topology, depth, i), <span class="stringliteral">&quot;#&quot;</span>, 0);
                        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <span class="keywordtype">string</span>);
                }
        }

        <span class="comment">/* Walk the topology with a tree style.  */</span>
        print_children(topology, <a class="code" href="group__hwlocality__helper__traversal__basic.html#gab39658e42f1046db0f8870a0d0ba9f42" title="Returns the top-object of the topology-tree. Its type is HWLOC_OBJ_SYSTEM.">hwloc_get_system_obj</a>(topology), 0);


        <span class="comment">/* Print the number of sockets.  */</span>
        depth = <a class="code" href="group__hwlocality__information.html#ga8bec782e21be313750da70cf7428b374" title="Returns the depth of objects of type type.">hwloc_get_type_depth</a>(topology, <a class="code" href="group__hwlocality__types.html#ggacd37bb612667dc437d66bfb175a8dc55a1ac6e07775ae4324b3fe9dbd72c785ec" title="Socket, physical package, or chip. In the physical meaning, i.e. that you can add...">HWLOC_OBJ_SOCKET</a>);
        <span class="keywordflow">if</span> (depth == <a class="code" href="group__hwlocality__information.html#ga9e86ce528f626330de2da7adb6c4e02e" title="No object of given type exists in the topology.">HWLOC_TYPE_DEPTH_UNKNOWN</a>)
                printf(<span class="stringliteral">&quot;The number of sockets is unknown\n&quot;</span>);
        <span class="keywordflow">else</span>
                printf(<span class="stringliteral">&quot;%u socket(s)\n&quot;</span>, <a class="code" href="group__hwlocality__information.html#gab17065e3d53455973844568d9f21c72c" title="Returns the width of level at depth depth.">hwloc_get_nbobjs_by_depth</a>(topology, depth));


        <span class="comment">/* Find out where cores are, or else smaller sets of CPUs if the OS</span>
<span class="comment">         * doesn&apos;t have the notion of core. */</span>
        depth = <a class="code" href="group__hwlocality__helper__types.html#gaa0835c86ef2ce8c62637d61a1cf134f9" title="Returns the depth of objects of type type or below.">hwloc_get_type_or_below_depth</a>(topology, <a class="code" href="group__hwlocality__types.html#ggacd37bb612667dc437d66bfb175a8dc55ac793958f330bca371aa1535de8aff45f" title="Core. A computation unit (may be shared by several logical processors).">HWLOC_OBJ_CORE</a>);

        <span class="comment">/* Get last one.  */</span>
        <a class="code" href="structhwloc__obj.html" title="Structure of a topology object.">hwloc_obj_t</a> obj = <a class="code" href="group__hwlocality__traversal.html#gabf8a98ad085460a4982cc7b74c344b71" title="Returns the topology object at index index from depth depth.">hwloc_get_obj_by_depth</a>(topology, depth, <a class="code" href="group__hwlocality__information.html#gab17065e3d53455973844568d9f21c72c" title="Returns the width of level at depth depth.">hwloc_get_nbobjs_by_depth</a>(topology, depth) - 1);
        <span class="keywordflow">if</span> (!obj)
                <span class="keywordflow">return</span> 0;

        <span class="comment">/* Get a copy of its cpuset that we may modify.  */</span>
        <a class="code" href="group__hwlocality__cpuset.html#ga7366332f7090f5b54d4b25a0c2c4b411" title="Set of CPUs represented as an opaque pointer to an internal bitmask.">hwloc_cpuset_t</a> cpuset = <a class="code" href="group__hwlocality__cpuset.html#ga19d8c163e4834ba69c808560aa5a89b3" title="Duplicate CPU set set by allocating a new CPU set and copying its contents.">hwloc_cpuset_dup</a>(obj-&gt;<a class="code" href="structhwloc__obj.html#a67925e0f2c47f50408fbdb9bddd0790f" title="CPUs covered by this object.">cpuset</a>);

        <span class="comment">/* Get only one logical processor (in case the core is SMT/hyperthreaded).  */</span>
        <a class="code" href="group__hwlocality__cpuset.html#ga548a6620cce008fc5b1e2110d25135fe" title="Keep a single CPU among those set in CPU set set.">hwloc_cpuset_singlify</a>(cpuset);

        <span class="comment">/* And try to bind ourself there.  */</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__hwlocality__binding.html#ga47053da286384d86ec3e4fb3fe148dae" title="Bind current process or thread on cpus given in cpuset set.">hwloc_set_cpubind</a>(topology, cpuset, 0)) {
                <span class="keywordtype">char</span> *str = NULL;
                <a class="code" href="group__hwlocality__cpuset.html#ga29160016d2e89318b5db99046d93dc0a" title="Stringify a cpuset into a newly allocated string.">hwloc_cpuset_asprintf</a>(&amp;str, obj-&gt;<a class="code" href="structhwloc__obj.html#a67925e0f2c47f50408fbdb9bddd0790f" title="CPUs covered by this object.">cpuset</a>);
                printf(<span class="stringliteral">&quot;Couldn&apos;t bind to cpuset %s\n&quot;</span>, str);
                free(str);
        }

        <span class="comment">/* Free our cpuset copy */</span>
        <a class="code" href="group__hwlocality__cpuset.html#gaf5d5a9e082a43f8311fdcff55e611b23" title="Free CPU set set.">hwloc_cpuset_free</a>(cpuset);

        <span class="comment">/* Destroy topology object.  */</span>
        <a class="code" href="group__hwlocality__creation.html#ga9f34a640b6fd28d23699d4d084667b15" title="Terminate and free a topology context.">hwloc_topology_destroy</a>(topology);

        <span class="keywordflow">return</span> 0;
}
</pre></div> 
</div><div class="section" id="bugs">
 <h2><a class="anchor" id="bugs">
Questions and bugs</a></h2>
<p>Questions should be sent to the devel mailing list (<a href="http://www.open-mpi.org/community/lists/hwloc.php">http://www.open-mpi.org/community/lists/hwloc.php</a>). Bug reports should be reported in the tracker (<a href="https://svn.open-mpi.org/trac/hwloc/">https://svn.open-mpi.org/trac/hwloc/</a>).</p>
 
</div><div class="section" id="credits">
 <h2><a class="anchor" id="history">
History / credits</a></h2>
<p>hwloc is the evolution and merger of the libtopology (<a href="http://runtime.bordeaux.inria.fr/libtopology/">http://runtime.bordeaux.inria.fr/libtopology/</a>) project and the Portable Linux Processor Affinity (PLPA) (<a href="http://www.open-mpi.org/projects/plpa/">http://www.open-mpi.org/projects/plpa/</a>) project. Because of functional and ideological overlap, these two code bases and ideas were merged and released under the name "hwloc" as an Open MPI sub-project.</p>
<p>libtopology was initially developed by the INRIA Runtime Team-Project (<a href="http://runtime.bordeaux.inria.fr/">http://runtime.bordeaux.inria.fr/</a>) (headed by Raymond Namyst (<a href="http://dept-info.labri.fr/~namyst/">http://dept-info.labri.fr/~namyst/</a>). PLPA was initially developed by the Open MPI development team as a sub-project. Both are now deprecated in favor of hwloc, which is distributed as an Open MPI sub-project.</p>
 
</div>
 </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 5 09:58:42 2009 for Hardware Locality (hwloc) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
