.TH "Advanced I/O object traversal helpers" 3 "Mon Feb 27 2012" "Version 1.4.1" "Hardware Locality (hwloc)" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Advanced I/O object traversal helpers \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_non_io_ancestor_obj\fP (\fBhwloc_topology_t\fP topology , \fBhwloc_obj_t\fP ioobj)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_pcidev\fP (\fBhwloc_topology_t\fP topology, \fBhwloc_obj_t\fP prev)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_pcidev_by_busid\fP (\fBhwloc_topology_t\fP topology, unsigned domain, unsigned bus, unsigned dev, unsigned func)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_pcidev_by_busidstring\fP (\fBhwloc_topology_t\fP topology, const char *busid)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_osdev\fP (\fBhwloc_topology_t\fP topology, \fBhwloc_obj_t\fP prev)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_bridge\fP (\fBhwloc_topology_t\fP topology, \fBhwloc_obj_t\fP prev)"
.br
.ti -1c
.RI "static inline int \fBhwloc_bridge_covers_pcibus\fP (\fBhwloc_obj_t\fP bridge, unsigned domain, unsigned bus)"
.br
.ti -1c
.RI "static inline \fBhwloc_obj_t\fP \fBhwloc_get_hostbridge_by_pcibus\fP (\fBhwloc_topology_t\fP topology, unsigned domain, unsigned bus)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static inline int \fBhwloc_bridge_covers_pcibus\fP (\fBhwloc_obj_t\fPbridge, unsigneddomain, unsignedbus)\fC [static]\fP"
.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_hostbridge_by_pcibus\fP (\fBhwloc_topology_t\fPtopology, unsigneddomain, unsignedbus)\fC [static]\fP"
.PP
Find the hostbridge that covers the given PCI bus\&. This is useful for finding the locality of a bus because it is the hostbridge parent cpuset\&. 
.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_bridge\fP (\fBhwloc_topology_t\fPtopology, \fBhwloc_obj_t\fPprev)\fC [static]\fP"
.PP
Get the next bridge in the system\&. \fBReturns:\fP
.RS 4
the first bridge if \fCprev\fP is \fCNULL\fP\&. 
.RE
.PP

.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_osdev\fP (\fBhwloc_topology_t\fPtopology, \fBhwloc_obj_t\fPprev)\fC [static]\fP"
.PP
Get the next OS device in the system\&. \fBReturns:\fP
.RS 4
the first OS device if \fCprev\fP is \fCNULL\fP\&. 
.RE
.PP

.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_next_pcidev\fP (\fBhwloc_topology_t\fPtopology, \fBhwloc_obj_t\fPprev)\fC [static]\fP"
.PP
Get the next PCI device in the system\&. \fBReturns:\fP
.RS 4
the first PCI device if \fCprev\fP is \fCNULL\fP\&. 
.RE
.PP

.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_non_io_ancestor_obj\fP (\fBhwloc_topology_t\fP topology, \fBhwloc_obj_t\fPioobj)\fC [static]\fP"
.PP
Get the first non-I/O ancestor object\&. Given the I/O object \fCioobj\fP, find the smallest non-I/O ancestor object\&. This regular object may then be used for binding because its locality is the same as \fCioobj\fP\&. 
.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_pcidev_by_busid\fP (\fBhwloc_topology_t\fPtopology, unsigneddomain, unsignedbus, unsigneddev, unsignedfunc)\fC [static]\fP"
.PP
Find the PCI device object matching the PCI bus id given domain, bus device and function PCI bus id\&. 
.SS "static inline \fBhwloc_obj_t\fP \fBhwloc_get_pcidev_by_busidstring\fP (\fBhwloc_topology_t\fPtopology, const char *busid)\fC [static]\fP"
.PP
Find the PCI device object matching the PCI bus id given as a string xxxx:yy:zz\&.t or yy:zz\&.t\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Hardware Locality (hwloc) from the source code\&.
